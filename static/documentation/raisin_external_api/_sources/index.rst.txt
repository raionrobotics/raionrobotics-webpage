Raisin External API Reference
==============================

외부 시스템에서 Raibo2의 자율주행 기능을 제어하기 위한 API 문서입니다.

`English Version <../en/index.html>`_

Overview
--------

Raisin 시스템은 외부 연동을 위해 두 가지 방식을 제공합니다:

.. list-table::
   :header-rows: 1
   :widths: 20 40 40

   * - 방식
     - 설명
     - 용도
   * - **API Example**
     - ``RaisinClient`` 래퍼 클래스 예제 코드
     - 빠른 시작, 참고용 구현체
   * - **Direct Network**
     - ``raisin_network`` 라이브러리 직접 사용
     - 커스텀 서비스 호출, 세밀한 제어 필요 시

.. note::
    **API Example (RaisinClient)** 는 공식 지원 SDK가 아닌 예제 코드입니다.
    외부 개발자가 Raisin 플랫폼을 연동하는 방법을 보여주는 참고용 구현체이며,
    필요에 따라 수정하여 사용하시기 바랍니다.

.. code-block:: text

    +------------------------------------------+
    |           External Application           |
    +------------------------------------------+
    |  Option A: API Example                   |
    |  +------------------------------------+  |
    |  |  #include "raisin_client.hpp"   |  |
    |  |  RaisinClient client;           |  |
    |  |  client.connect("ROBOT_ID");      |  |
    |  |  client.setMap(...);              |  |
    |  |  client.setWaypoints(...);        |  |
    |  +------------------------------------+  |
    +------------------------------------------+
    |  Option B: Direct Network                |
    |  +------------------------------------+  |
    |  |  raisin::Network network;         |  |
    |  |  raisin::Node node;               |  |
    |  |  auto client = node.createClient  |  |
    |  |      <SetWaypoints>(...);         |  |
    |  +------------------------------------+  |
    +------------------------------------------+
                      |
                      | WebSocket
                      v
    +------------------------------------------+
    |                 Raibo2                   |
    |  +----------------+  +----------------+  |
    |  | Autonomy Plugin|  | Fast-LIO Plugin|  |
    |  | - Waypoints    |  | - Localization |  |
    |  | - Navigation   |  | - Map Loading  |  |
    |  +----------------+  +----------------+  |
    +------------------------------------------+

Integration Package
-------------------

패키지 구성
^^^^^^^^^^^

``raisin_sdk_install/`` 폴더에는 다음이 포함됩니다:

.. code-block:: text

    raisin_sdk_install/
    ├── include/                    # 헤더 파일
    │   ├── raisin_network/         # 네트워크 라이브러리
    │   ├── raisin_interfaces/      # 메시지/서비스 정의
    │   └── ...
    └── lib/                        # 컴파일된 라이브러리
        ├── libraisin_network.so
        ├── libraisin_interfaces.so
        └── ...

시스템 요구사항
^^^^^^^^^^^^^^^

.. code-block:: bash

    # Ubuntu 22.04
    sudo apt-get install libeigen3-dev libssl-dev libpcl-dev libopencv-dev

네트워크 요구사항
^^^^^^^^^^^^^^^^^

- 로봇과 클라이언트가 **동일 네트워크**에 있어야 합니다
- 멀티캐스트 트래픽이 허용되어야 합니다 (Robot ID 자동 발견용)
- 방화벽: TCP/UDP 포트 8080, 38371 등 허용 필요

Robot ID 확인
^^^^^^^^^^^^^

Robot ID는 ``raisin_master`` 실행 시 콘솔에 출력됩니다:

.. code-block:: text

    [raisin_master] Robot ID: railab_raibo-3614732983840
    [raisin_master] Listening on port 38371

또는 raisin_gui에서 확인할 수 있습니다.

----

API Example Reference
---------------------

``RaisinClient`` 래퍼 클래스를 사용한 예제 코드입니다. 필요에 따라 수정하여 사용하세요.

헤더 포함
^^^^^^^^^

.. code-block:: cpp

    #include "raisin_sdk/raisin_client.hpp"

기본 워크플로우
^^^^^^^^^^^^^^^

.. code-block:: cpp

    // 1. 클라이언트 생성
    raisin_sdk::RaisinClient client("my_app");

    // 2. 로봇 연결
    client.connect("ROBOT_ID");

    // 3. 맵 로드 (Localization 활성화)
    client.setMap("/path/to/map.pcd", 0.0, 0.0, 0.0, 0.0, "my_map");

    // 4. Waypoint 설정 (frame은 반드시 map_name과 동일해야 함!)
    std::vector<raisin_sdk::Waypoint> waypoints = {
        raisin_sdk::Waypoint("my_map", 5.0, 0.0),   // "my_map" 사용
        raisin_sdk::Waypoint("my_map", 5.0, 5.0),
    };
    client.setWaypoints(waypoints, 1);

    // 5. 상태 모니터링
    auto status = client.getMissionStatus();

.. _data-types:

Data Types
^^^^^^^^^^

**Waypoint** - 네비게이션 목표 지점

.. code-block:: cpp

    struct Waypoint {
        std::string frame;  // 좌표 프레임 (중요!)
        double x, y, z;     // 좌표
        bool use_z;         // Z 좌표 사용 여부
    };

    // 생성 방법
    Waypoint("map_name", x, y);           // 맵 좌표
    Waypoint::GPS(latitude, longitude);   // GPS 좌표 (GPS 모듈 필요)

.. warning::
    **frame 이름은 setMap()에서 지정한 map_name과 반드시 일치해야 합니다!**

    .. code-block:: cpp

        // 올바른 예시
        client.setMap("/path/map.pcd", 0, 0, 0, 0, "office_map");
        Waypoint("office_map", 5.0, 0.0);  // ✓ 동일한 이름

        // 잘못된 예시
        client.setMap("/path/map.pcd", 0, 0, 0, 0, "office_map");
        Waypoint("map", 5.0, 0.0);  // ✗ 이름 불일치 - 동작 안함!

**MissionStatus** - 미션 상태

.. code-block:: cpp

    struct MissionStatus {
        std::vector<Waypoint> waypoints;  // 현재 waypoint 목록
        uint8_t current_index;            // 현재 목표 인덱스
        uint8_t repetition;               // 남은 반복 횟수 (0=무한)
        bool valid;                       // 데이터 유효성
    };

**ServiceResult** - 서비스 호출 결과

.. code-block:: cpp

    struct ServiceResult {
        bool success;         // 성공 여부
        std::string message;  // 결과 메시지
    };

**RobotState** - 로봇 상태 (Odometry)

.. code-block:: cpp

    struct RobotState {
        double x, y, z;    // 위치 (meters)
        double yaw;        // 방향 (radians)
        double vx, vy;     // 선속도 (m/s)
        double omega;      // 각속도 (rad/s)
        bool valid;
    };

**Point3D** - 포인트 클라우드 점

.. code-block:: cpp

    struct Point3D { float x, y, z; };

**ActuatorInfo** - 액추에이터(모터) 정보

.. code-block:: cpp

    struct ActuatorInfo {
        std::string name;           // 모터 이름 (e.g., "FR_hip", "FL_thigh")
        uint16_t status;            // 상태 코드 (0 = 정상)
        double temperature;         // 모터 온도 (°C)
        double position;            // 관절 위치 (rad)
        double velocity;            // 관절 속도 (rad/s)
        double effort;              // 관절 토크 (Nm)
    };

**LocomotionState** - 로봇 locomotion 상태 열거형

.. code-block:: cpp

    enum class LocomotionState : int32_t {
        COMM_DISABLED = 0,      // 통신 비활성
        COMM_ENABLED = 1,       // 통신 활성
        MOTOR_READY = 2,        // 모터 준비
        MOTOR_COMMUTATION = 3,  // 모터 정류 중
        MOTOR_ENABLED = 4,      // 모터 활성
        IN_TEST_MODE = 5,       // 테스트 모드
        STANDING_MODE = 6,      // 서있는 상태
        IN_CONTROL = 7,         // 제어 중 (걷기)
        SITDOWN_MODE = 8,       // 앉은 상태
        MOTOR_DISABLED = 9      // 모터 비활성
    };

**JoySourceType** - 조이스틱 제어 소스 타입

.. code-block:: cpp

    enum class JoySourceType : int32_t {
        JOY = 0,           // 수동 조이스틱 제어
        VEL_CMD = 1,       // 자율주행 속도 명령
        NUM_SOURCES = 2    // 제어 소스 없음
    };

**ExtendedRobotState** - 확장 로봇 상태 (배터리, 모터 상태 포함)

.. code-block:: cpp

    struct ExtendedRobotState {
        // 위치 및 속도
        double x, y, z;             // 위치 (meters)
        double yaw;                 // 방향 (radians)
        double vx, vy;              // 선속도 (m/s)
        double omega;               // 각속도 (rad/s)

        // Locomotion 상태
        int32_t locomotion_state;   // LocomotionState 열거형 값 (0-9)

        // 배터리 정보
        double voltage;             // 현재 전압 (V)
        double current;             // 전류 (A)
        double max_voltage;         // 최대 전압
        double min_voltage;         // 최소 전압

        // 온도
        double body_temperature;    // 본체 온도 (°C)

        // 조이스틱 제어 상태
        int32_t joy_listen_type;    // JoySourceType 열거형 값

        // 액추에이터 상태
        std::vector<ActuatorInfo> actuators;

        bool valid;

        // 유틸리티 메서드
        std::string getLocomotionStateName() const;  // 상태명 문자열
        std::string getJoySourceName() const;        // 제어 소스명 문자열
        bool isOperational() const;                  // 서있거나 걷는 중인지
        bool hasActuatorError() const;               // 모터 에러 여부
    };

RaisinClient Methods
^^^^^^^^^^^^^^^^^^^^^^

**connect()**

.. code-block:: cpp

    bool connect(const std::string& robot_id, int timeout_sec = 10);

로봇에 연결합니다.

- ``robot_id``: Robot ID 또는 IP 주소
- ``timeout_sec``: 연결 타임아웃 (초)
- **반환**: 연결 성공 여부

**setMap()**

.. code-block:: cpp

    ServiceResult setMap(const std::string& pcd_path,
                         double initial_x, double initial_y,
                         double initial_z, double initial_yaw,
                         const std::string& map_name);

PCD 맵 파일을 로드하고 Localization을 초기화합니다.

- ``pcd_path``: PCD 파일 경로 (**클라이언트 PC에 있는 파일**, 로봇으로 전송됨)
- ``initial_x/y/z``: 맵 내 로봇 초기 위치 (로봇이 물리적으로 있는 위치를 맵 좌표로 입력)
- ``initial_yaw``: 초기 방향 (radians)
- ``map_name``: 맵 프레임 이름 (**Waypoint frame과 일치해야 함**)

.. note::
    PCD 맵은 사전에 SLAM으로 생성해야 합니다. raisin_gui의 Mapping 기능을 사용하거나,
    Fast-LIO 플러그인으로 직접 생성할 수 있습니다.

**setWaypoints()**

.. code-block:: cpp

    ServiceResult setWaypoints(const std::vector<Waypoint>& waypoints,
                                uint8_t repetition = 1,
                                uint8_t start_index = 0);

Waypoint 목록을 설정하고 네비게이션을 시작합니다.

- ``waypoints``: Waypoint 목록
- ``repetition``: 반복 횟수

  - ``0`` = 무한 순찰
  - ``1`` = 1회 통과 (기본값)
  - ``N`` = N회 반복

- ``start_index``: 시작 waypoint 인덱스

**getMissionStatus()**

.. code-block:: cpp

    MissionStatus getMissionStatus();

현재 미션 상태를 조회합니다.

**appendWaypoint()**

.. code-block:: cpp

    ServiceResult appendWaypoint(const Waypoint& waypoint);

현재 미션 큐에 waypoint를 추가합니다.

**stopNavigation()**

.. code-block:: cpp

    ServiceResult stopNavigation();

자율주행을 중지합니다 (빈 waypoint 목록 설정).

**startPatrol()**

.. code-block:: cpp

    ServiceResult startPatrol(const std::vector<Waypoint>& waypoints);

무한 순찰을 시작합니다 (``setWaypoints(waypoints, 0)``과 동일).

**subscribeOdometry()**

.. code-block:: cpp

    void subscribeOdometry(std::function<void(const RobotState&)> callback);

Odometry 데이터를 실시간 구독합니다.

**subscribePointCloud()**

.. code-block:: cpp

    void subscribePointCloud(std::function<void(const std::vector<Point3D>&)> callback);

LiDAR 포인트 클라우드를 실시간 구독합니다.

**getRobotState() / getLatestPointCloud()**

.. code-block:: cpp

    RobotState getRobotState();
    std::vector<Point3D> getLatestPointCloud();

마지막으로 수신한 데이터를 반환합니다 (thread-safe).

**loadPCD() (static)**

.. code-block:: cpp

    static std::vector<Point3D> loadPCD(const std::string& pcd_path);

PCD 파일을 로드합니다 (로봇 전송 없이 시각화용).

**subscribeRobotState()**

.. code-block:: cpp

    void subscribeRobotState(std::function<void(const ExtendedRobotState&)> callback);

확장 로봇 상태를 실시간 구독합니다. 배터리 정보, locomotion 상태, 액추에이터 상태 등을 포함합니다.

.. code-block:: cpp

    client.subscribeRobotState([](const raisin_sdk::ExtendedRobotState& state) {
        std::cout << "Locomotion: " << state.getLocomotionStateName() << std::endl;
        std::cout << "Battery: " << state.voltage << "V" << std::endl;
        std::cout << "Control: " << state.getJoySourceName() << std::endl;

        if (state.hasActuatorError()) {
            std::cerr << "Warning: Actuator error detected!" << std::endl;
        }
    });

**getExtendedRobotState()**

.. code-block:: cpp

    ExtendedRobotState getExtendedRobotState();

마지막으로 수신한 확장 로봇 상태를 반환합니다 (thread-safe).
``subscribeRobotState()``를 먼저 호출해야 유효한 데이터를 얻을 수 있습니다.

**enableJoyControl()**

.. code-block:: cpp

    ServiceResult enableJoyControl(const std::string& topic_name = "joy");

수동 조이스틱 제어를 활성화합니다.

- ``topic_name``: 조이스틱 토픽 이름 (기본값: "joy")
- **반환**: 서비스 호출 결과

.. code-block:: cpp

    auto result = client.enableJoyControl();
    if (result.success) {
        std::cout << "Manual control enabled" << std::endl;
    }

**disableJoyControl()**

.. code-block:: cpp

    ServiceResult disableJoyControl(const std::string& topic_name = "joy");

조이스틱 제어를 비활성화합니다 (수동 조작 잠금).

- ``topic_name``: 조이스틱 토픽 이름 (기본값: "joy")
- **반환**: 서비스 호출 결과

.. code-block:: cpp

    auto result = client.disableJoyControl();
    if (result.success) {
        std::cout << "Joystick control locked" << std::endl;
    }

.. note::
    조이스틱 제어 상태는 ``ExtendedRobotState.joy_listen_type``으로 확인할 수 있습니다:

    - ``JOY (0)``: 수동 조이스틱 제어 활성
    - ``VEL_CMD (1)``: 자율주행 속도 명령 수신 중
    - ``NUM_SOURCES (2)``: 제어 소스 없음 (잠금 상태)

GPS 사용 시 주의사항
^^^^^^^^^^^^^^^^^^^^

.. code-block:: cpp

    Waypoint::GPS(37.5665, 126.9780);

- **GPS 모듈이 로봇에 장착**되어 있어야 합니다
- GPS fix가 유효해야 합니다 (``/fix`` 토픽)
- GPS가 없으면 ``setWaypoints()``는 성공하지만 로봇이 목표에 도달하지 못합니다

----

Direct Network API
------------------

고급 사용자를 위한 ``raisin_network`` 직접 사용 방법입니다.

헤더 포함
^^^^^^^^^

.. code-block:: cpp

    #include "raisin_network/raisin.hpp"
    #include "raisin_network/network.hpp"
    #include "raisin_network/node.hpp"
    #include "raisin_interfaces/srv/set_waypoints.hpp"
    #include "raisin_interfaces/srv/get_waypoints.hpp"
    #include "raisin_interfaces/srv/append_waypoint.hpp"
    #include "raisin_interfaces/srv/set_laser_map.hpp"
    #include "raisin_interfaces/srv/string.hpp"       // Joy 제어용
    #include "raisin_interfaces/msg/robot_state.hpp"  // 로봇 상태 토픽

연결 패턴
^^^^^^^^^

.. code-block:: cpp

    // 1. 초기화
    raisin::raisinInit();

    // 2. 네트워크 생성
    std::vector<std::vector<std::string>> threads = {{"main"}};
    auto network = std::make_shared<raisin::Network>(
        "my_client",      // 클라이언트 ID
        "external",       // 디바이스 타입
        threads
    );

    std::this_thread::sleep_for(std::chrono::seconds(1));

    // 3. 로봇 연결
    auto connection = network->connect("ROBOT_ID");
    if (!connection) {
        std::cerr << "Connection failed" << std::endl;
        return -1;
    }

    std::this_thread::sleep_for(std::chrono::seconds(2));

    // 4. Node 생성
    raisin::Node node(network);

서비스 클라이언트 생성
^^^^^^^^^^^^^^^^^^^^^^

.. code-block:: cpp

    // Waypoint 설정 클라이언트
    auto setClient = node.createClient<raisin::raisin_interfaces::srv::SetWaypoints>(
        "planning/set_waypoints", connection);

    // Waypoint 조회 클라이언트
    auto getClient = node.createClient<raisin::raisin_interfaces::srv::GetWaypoints>(
        "planning/get_waypoints", connection);

    // Waypoint 추가 클라이언트
    auto appendClient = node.createClient<raisin::raisin_interfaces::srv::AppendWaypoint>(
        "planning/append_waypoint", connection);

    // 맵 설정 클라이언트
    auto mapClient = node.createClient<raisin::raisin_interfaces::srv::SetLaserMap>(
        "set_map", connection);

    // Joy 제어 클라이언트
    auto joyListenClient = node.createClient<raisin::raisin_interfaces::srv::String>(
        "set_listen", connection);

    // 서비스 대기
    if (!setClient->waitForService(std::chrono::seconds(10))) {
        std::cerr << "Service not available" << std::endl;
    }

서비스 호출 예시
^^^^^^^^^^^^^^^^

.. code-block:: cpp

    // SetWaypoints 요청 생성
    auto request = std::make_shared<raisin::raisin_interfaces::srv::SetWaypoints::Request>();

    raisin::raisin_interfaces::msg::Waypoint wp;
    wp.frame = "my_map";
    wp.x = 5.0;
    wp.y = 0.0;
    wp.z = 0.0;
    wp.use_z = false;
    request->waypoints.push_back(wp);

    request->repetition = 1;
    request->current_index = 0;

    // 비동기 호출
    auto future = setClient->asyncSendRequest(request);

    if (future.wait_for(std::chrono::seconds(5)) == std::future_status::ready) {
        auto response = future.get();
        std::cout << "Success: " << response->success << std::endl;
        std::cout << "Message: " << response->message << std::endl;
    }

구독자 생성
^^^^^^^^^^^

.. code-block:: cpp

    // Odometry 구독
    auto odomSub = node.createSubscriber<raisin::nav_msgs::msg::Odometry>(
        "/Odometry", connection,
        [](const raisin::nav_msgs::msg::Odometry::SharedPtr& msg) {
            std::cout << "Position: " << msg->pose.pose.position.x
                      << ", " << msg->pose.pose.position.y << std::endl;
        });

    // PointCloud 구독
    auto cloudSub = node.createSubscriber<raisin::sensor_msgs::msg::PointCloud2>(
        "/cloud_registered", connection,
        [](const raisin::sensor_msgs::msg::PointCloud2::SharedPtr& msg) {
            std::cout << "Points: " << msg->width * msg->height << std::endl;
        });

    // RobotState 구독 (배터리, locomotion 상태, 액추에이터 등)
    auto stateSub = node.createSubscriber<raisin::raisin_interfaces::msg::RobotState>(
        "robot_state", connection,
        [](const raisin::raisin_interfaces::msg::RobotState::SharedPtr& msg) {
            std::cout << "Locomotion state: " << msg->state << std::endl;
            std::cout << "Battery: " << msg->voltage << "V / " << msg->current << "A" << std::endl;
            std::cout << "Joy source: " << msg->joy_listen_type << std::endl;
            std::cout << "Actuators: " << msg->actuator_states.size() << std::endl;
        });

Joy 제어 서비스 호출
^^^^^^^^^^^^^^^^^^^^

.. code-block:: cpp

    // 수동 조이스틱 제어 활성화
    auto enableRequest = std::make_shared<raisin::raisin_interfaces::srv::String::Request>();
    enableRequest->data = "joy<&>my_client_id";  // "토픽명<&>클라이언트ID"

    auto future = joyListenClient->asyncSendRequest(enableRequest);
    if (future.wait_for(std::chrono::seconds(5)) == std::future_status::ready) {
        auto response = future.get();
        std::cout << "Enable joy: " << response->success << std::endl;
    }

    // 조이스틱 제어 비활성화 (잠금)
    auto disableRequest = std::make_shared<raisin::raisin_interfaces::srv::String::Request>();
    disableRequest->data = "joy<&><CLOSE>";  // "토픽명<&><CLOSE>"

    auto future2 = joyListenClient->asyncSendRequest(disableRequest);
    if (future2.wait_for(std::chrono::seconds(5)) == std::future_status::ready) {
        auto response = future2.get();
        std::cout << "Disable joy: " << response->success << std::endl;
    }

----

Service Interface Reference
----------------------------

사용 가능한 서비스 인터페이스 정의입니다.

planning/set_waypoints
^^^^^^^^^^^^^^^^^^^^^^

Waypoint 목록을 설정합니다.

**Request:**

.. list-table::
   :header-rows: 1
   :widths: 20 20 60

   * - Field
     - Type
     - Description
   * - waypoints
     - Waypoint[]
     - Waypoint 배열
   * - repetition
     - uint8
     - 반복 횟수 (0=무한)
   * - current_index
     - uint8
     - 시작 인덱스

**Response:**

.. list-table::
   :header-rows: 1
   :widths: 20 20 60

   * - Field
     - Type
     - Description
   * - success
     - bool
     - 성공 여부
   * - message
     - string
     - 결과 메시지

**가능한 Response 메시지:**

- ``"set waypoint success"`` - 성공
- ``"waypoint list is empty"`` - waypoint가 비어있음
- ``"service timeout"`` - 서비스 응답 없음

planning/get_waypoints
^^^^^^^^^^^^^^^^^^^^^^

현재 미션 상태를 조회합니다.

**Request:** (empty)

**Response:**

.. list-table::
   :header-rows: 1
   :widths: 20 20 60

   * - Field
     - Type
     - Description
   * - success
     - bool
     - 성공 여부
   * - message
     - string
     - 결과 메시지
   * - waypoints
     - Waypoint[]
     - 현재 waypoint 목록
   * - repetition
     - uint8
     - 남은 반복 횟수
   * - current_index
     - uint8
     - 현재 목표 인덱스

planning/append_waypoint
^^^^^^^^^^^^^^^^^^^^^^^^

Waypoint를 큐에 추가합니다.

**Request:**

.. list-table::
   :header-rows: 1
   :widths: 20 20 60

   * - Field
     - Type
     - Description
   * - waypoint
     - Waypoint
     - 추가할 waypoint

**Response:**

.. list-table::
   :header-rows: 1
   :widths: 20 20 60

   * - Field
     - Type
     - Description
   * - success
     - bool
     - 성공 여부
   * - message
     - string
     - 결과 메시지

set_map (SetLaserMap)
^^^^^^^^^^^^^^^^^^^^^

PCD 맵을 로드하고 Localization을 초기화합니다.

**Request:**

.. list-table::
   :header-rows: 1
   :widths: 20 20 60

   * - Field
     - Type
     - Description
   * - name
     - string
     - 맵 프레임 이름
   * - pc
     - PointCloud2
     - 포인트 클라우드 데이터
   * - initial_pose
     - Pose
     - 초기 로봇 자세

**Response:**

.. list-table::
   :header-rows: 1
   :widths: 20 20 60

   * - Field
     - Type
     - Description
   * - success
     - bool
     - 성공 여부
   * - message
     - string
     - 결과 메시지

**가능한 Response 메시지:**

- ``"Map saved."`` - 성공
- ``"service timeout"`` - Fast-LIO 플러그인 미로드

Waypoint Message
^^^^^^^^^^^^^^^^

.. code-block:: text

    string frame      # 좌표 프레임: "map_name", "gps", "odom"
    float64 x         # X 좌표 (GPS: latitude)
    float64 y         # Y 좌표 (GPS: longitude)
    float64 z         # Z 좌표 (GPS: altitude)
    bool use_z        # Z 좌표 검사 여부

set_listen (Joy 제어)
^^^^^^^^^^^^^^^^^^^^^

수동 조이스틱 제어를 활성화/비활성화합니다.

**Request:**

.. list-table::
   :header-rows: 1
   :widths: 20 20 60

   * - Field
     - Type
     - Description
   * - data
     - string
     - 제어 명령 문자열

**Request data 형식:**

- 활성화: ``"토픽명<&>클라이언트ID"`` (예: ``"joy<&>my_app"``)
- 비활성화: ``"토픽명<&><CLOSE>"`` (예: ``"joy<&><CLOSE>"``)

**Response:**

.. list-table::
   :header-rows: 1
   :widths: 20 20 60

   * - Field
     - Type
     - Description
   * - success
     - bool
     - 성공 여부
   * - message
     - string
     - 결과 메시지

robot_state (Topic)
^^^^^^^^^^^^^^^^^^^

로봇의 상태 정보를 발행하는 토픽입니다.

**토픽명:** ``robot_state``

**메시지 필드:**

.. list-table::
   :header-rows: 1
   :widths: 25 20 55

   * - Field
     - Type
     - Description
   * - actuator_states
     - ActuatorState[]
     - 액추에이터(모터) 상태 배열
   * - base_pos
     - double[3]
     - 베이스 위치 [x, y, z]
   * - base_quat
     - double[4]
     - 베이스 쿼터니언 [x, y, z, w]
   * - base_lin_vel
     - double[3]
     - 선속도 [vx, vy, vz]
   * - base_ang_vel
     - double[3]
     - 각속도 [wx, wy, wz]
   * - voltage
     - double
     - 현재 배터리 전압 (V)
   * - current
     - double
     - 현재 전류 (A)
   * - max_voltage
     - double
     - 최대 전압
   * - min_voltage
     - double
     - 최소 전압
   * - body_temperature
     - double
     - 본체 온도 (°C)
   * - state
     - int32
     - Locomotion 상태 (0-9)
   * - joy_listen_type
     - int32
     - Joy 소스 타입 (0=JOY, 1=VEL_CMD, 2=NONE)

**ActuatorState 메시지:**

.. list-table::
   :header-rows: 1
   :widths: 20 20 60

   * - Field
     - Type
     - Description
   * - name
     - string
     - 모터 이름 (예: "FR_hip")
   * - position
     - double
     - 관절 위치 (rad)
   * - velocity
     - double
     - 관절 속도 (rad/s)
   * - effort
     - double
     - 관절 토크 (Nm)
   * - status
     - uint16
     - 상태 코드 (0 = 정상)
   * - temperature
     - double
     - 모터 온도 (°C)

**Locomotion State 값:**

.. list-table::
   :header-rows: 1
   :widths: 15 85

   * - 값
     - 상태
   * - 0
     - COMM_DISABLED (통신 비활성)
   * - 1
     - COMM_ENABLED (통신 활성)
   * - 2
     - MOTOR_READY (모터 준비)
   * - 3
     - MOTOR_COMMUTATION (모터 정류 중)
   * - 4
     - MOTOR_ENABLED (모터 활성)
   * - 5
     - IN_TEST_MODE (테스트 모드)
   * - 6
     - STANDING_MODE (서있는 상태)
   * - 7
     - IN_CONTROL (제어 중/걷기)
   * - 8
     - SITDOWN_MODE (앉은 상태)
   * - 9
     - MOTOR_DISABLED (모터 비활성)

----

Complete Examples
-----------------

기본 Waypoint 제어
^^^^^^^^^^^^^^^^^^

.. code-block:: cpp

    #include <iostream>
    #include <thread>
    #include <chrono>
    #include "raisin_sdk/raisin_client.hpp"

    int main(int argc, char* argv[]) {
        if (argc < 2) {
            std::cout << "Usage: " << argv[0] << " <robot_id> [pcd_path]" << std::endl;
            return 1;
        }

        std::string robotId = argv[1];
        std::string pcdPath = (argc >= 3) ? argv[2] : "../maps/office1_example.pcd";

        // 클라이언트 생성 및 연결
        raisin_sdk::RaisinClient client("waypoint_example");

        std::cout << "Connecting to " << robotId << "..." << std::endl;
        if (!client.connect(robotId)) {
            std::cerr << "Connection failed!" << std::endl;
            return 1;
        }
        std::cout << "Connected!" << std::endl;

        // 맵 로드
        std::cout << "Loading map..." << std::endl;
        auto mapResult = client.setMap(pcdPath, 0.0, 0.0, 0.0, 0.0, "sdk_map");
        if (!mapResult.success) {
            std::cerr << "Map load failed: " << mapResult.message << std::endl;
            return 1;
        }
        std::cout << "Map loaded: " << mapResult.message << std::endl;

        // Waypoint 설정 (frame은 반드시 map_name과 동일!)
        std::vector<raisin_sdk::Waypoint> waypoints = {
            raisin_sdk::Waypoint("sdk_map", 0.0, 0.0),
            raisin_sdk::Waypoint("sdk_map", 5.0, 0.0),
            raisin_sdk::Waypoint("sdk_map", 5.0, 5.0),
            raisin_sdk::Waypoint("sdk_map", 0.0, 5.0),
            raisin_sdk::Waypoint("sdk_map", 0.0, 0.0),
        };

        std::cout << "Setting " << waypoints.size() << " waypoints..." << std::endl;
        auto result = client.setWaypoints(waypoints, 1);
        if (!result.success) {
            std::cerr << "Failed: " << result.message << std::endl;
            return 1;
        }
        std::cout << "Navigation started!" << std::endl;

        // 진행 상황 모니터링
        while (true) {
            auto status = client.getMissionStatus();
            if (status.valid) {
                std::cout << "\rProgress: waypoint " << (int)status.current_index
                          << "/" << status.waypoints.size()
                          << " | Laps: " << (int)status.repetition << "   " << std::flush;

                // 미션 완료 확인
                if (status.current_index >= status.waypoints.size() - 1 &&
                    status.repetition == 0) {
                    std::cout << "\nMission complete!" << std::endl;
                    break;
                }
            }
            std::this_thread::sleep_for(std::chrono::seconds(1));
        }

        client.disconnect();
        return 0;
    }

실시간 모니터링
^^^^^^^^^^^^^^^

.. code-block:: cpp

    #include <iostream>
    #include <atomic>
    #include <csignal>
    #include "raisin_sdk/raisin_client.hpp"

    std::atomic<bool> running{true};
    void signalHandler(int) { running = false; }

    int main(int argc, char* argv[]) {
        std::signal(SIGINT, signalHandler);

        raisin_sdk::RaisinClient client("monitor");
        if (!client.connect(argv[1])) return 1;

        // Odometry 구독
        client.subscribeOdometry([](const raisin_sdk::RobotState& state) {
            std::cout << "Position: (" << state.x << ", " << state.y << ") "
                      << "Yaw: " << state.yaw << " rad" << std::endl;
        });

        // PointCloud 구독
        client.subscribePointCloud([](const std::vector<raisin_sdk::Point3D>& cloud) {
            std::cout << "LiDAR points: " << cloud.size() << std::endl;
        });

        std::cout << "Monitoring... (Ctrl+C to stop)" << std::endl;
        while (running) {
            std::this_thread::sleep_for(std::chrono::milliseconds(100));
        }

        return 0;
    }

무한 순찰
^^^^^^^^^

.. code-block:: cpp

    // 무한 순찰 시작
    std::vector<raisin_sdk::Waypoint> patrol = {
        raisin_sdk::Waypoint("sdk_map", 0.0, 0.0),
        raisin_sdk::Waypoint("sdk_map", 10.0, 0.0),
        raisin_sdk::Waypoint("sdk_map", 10.0, 10.0),
        raisin_sdk::Waypoint("sdk_map", 0.0, 10.0),
    };

    client.startPatrol(patrol);  // 또는 client.setWaypoints(patrol, 0);

    // 순찰 중지
    client.stopNavigation();

로봇 상태 모니터링
^^^^^^^^^^^^^^^^^^

.. code-block:: cpp

    #include <iostream>
    #include <atomic>
    #include <csignal>
    #include "raisin_sdk/raisin_client.hpp"

    std::atomic<bool> running{true};
    void signalHandler(int) { running = false; }

    int main(int argc, char* argv[]) {
        std::signal(SIGINT, signalHandler);

        raisin_sdk::RaisinClient client("state_monitor");
        if (!client.connect(argv[1])) return 1;

        // 확장 로봇 상태 구독
        client.subscribeRobotState([](const raisin_sdk::ExtendedRobotState& state) {
            std::cout << "Locomotion: " << state.getLocomotionStateName()
                      << " | Battery: " << state.voltage << "V"
                      << " | Control: " << state.getJoySourceName()
                      << std::endl;

            // 모터 에러 확인
            if (state.hasActuatorError()) {
                for (const auto& act : state.actuators) {
                    if (act.status != 0) {
                        std::cerr << "Motor error: " << act.name
                                  << " (status=" << act.status << ")" << std::endl;
                    }
                }
            }
        });

        std::cout << "Monitoring... (Ctrl+C to stop)" << std::endl;
        while (running) {
            std::this_thread::sleep_for(std::chrono::milliseconds(100));
        }
        return 0;
    }

배터리 모니터링
^^^^^^^^^^^^^^^

.. code-block:: cpp

    client.subscribeRobotState([](const raisin_sdk::ExtendedRobotState& state) {
        // 배터리 잔량 계산 (선형 근사)
        double percentage = 0.0;
        if (state.max_voltage > state.min_voltage) {
            percentage = (state.voltage - state.min_voltage) /
                        (state.max_voltage - state.min_voltage) * 100.0;
        }

        std::cout << "Battery: " << state.voltage << "V (" << percentage << "%)"
                  << " | Current: " << state.current << "A"
                  << " | Temp: " << state.body_temperature << "°C"
                  << std::endl;

        // 저전압 경고
        if (percentage < 20.0) {
            std::cerr << "Warning: Low battery!" << std::endl;
        }
    });

수동/자율 제어 전환
^^^^^^^^^^^^^^^^^^^

.. code-block:: cpp

    raisin_sdk::RaisinClient client("control_switcher");
    if (!client.connect(argv[1])) return 1;

    // 현재 제어 상태 확인
    client.subscribeRobotState([](const raisin_sdk::ExtendedRobotState& state) {
        std::cout << "Current control: " << state.getJoySourceName() << std::endl;
    });

    // 수동 조이스틱 제어 활성화
    auto result = client.enableJoyControl();
    if (result.success) {
        std::cout << "Manual control enabled" << std::endl;
    }

    // ... 수동 조작 ...

    // 수동 제어 비활성화 (자율주행 전환 전)
    result = client.disableJoyControl();
    if (result.success) {
        std::cout << "Manual control disabled" << std::endl;
    }

    // 자율주행 시작
    client.setWaypoints(waypoints, 1);

Odometry 모니터링 (현재 위치)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. code-block:: cpp

    client.subscribeOdometry([](const raisin_sdk::RobotState& state) {
        std::cout << "Position: (" << state.x << ", " << state.y << ") "
                  << "Yaw: " << (state.yaw * 180.0 / M_PI) << " deg "
                  << "Vel: (" << state.vx << ", " << state.vy << ") m/s"
                  << std::endl;
    });

    // 또는 마지막 상태 조회
    auto state = client.getRobotState();
    if (state.valid) {
        std::cout << "Current position: (" << state.x << ", " << state.y << ")" << std::endl;
    }

PointCloud 구독 (LiDAR)
^^^^^^^^^^^^^^^^^^^^^^^

.. code-block:: cpp

    client.subscribePointCloud([](const std::vector<raisin_sdk::Point3D>& points) {
        std::cout << "Received " << points.size() << " points" << std::endl;

        // 포인트 처리 예시
        for (const auto& p : points) {
            // p.x, p.y, p.z 사용
        }
    });

    // 또는 마지막 포인트클라우드 조회
    auto cloud = client.getLatestPointCloud();

맵 로드 및 Localization
^^^^^^^^^^^^^^^^^^^^^^^

.. code-block:: cpp

    // PCD 맵 파일 로드 및 로봇에 전송
    auto result = client.setMap(
        "./office.pcd",  // PCD 파일 경로
        0.0, 0.0, 0.0,   // 초기 위치 (x, y, z)
        0.0,             // 초기 방향 (yaw, radians)
        "office_map"     // 맵 이름 (waypoint frame으로 사용)
    );

    if (result.success) {
        std::cout << "Map loaded: " << result.message << std::endl;
        // 이제 "office_map" 프레임으로 waypoint 설정 가능
        std::vector<raisin_sdk::Waypoint> waypoints = {
            raisin_sdk::Waypoint("office_map", 5.0, 0.0),
            raisin_sdk::Waypoint("office_map", 5.0, 5.0),
        };
        client.setWaypoints(waypoints, 1);
    }

미션 상태 조회
^^^^^^^^^^^^^^

.. code-block:: cpp

    auto status = client.getMissionStatus();
    if (status.valid) {
        std::cout << "Active waypoints: " << status.waypoints.size() << std::endl;
        std::cout << "Current target: " << (int)status.current_index << std::endl;
        std::cout << "Remaining laps: " << (int)status.repetition << std::endl;

        // 각 waypoint 확인
        for (size_t i = 0; i < status.waypoints.size(); ++i) {
            const auto& wp = status.waypoints[i];
            std::string state = (i < status.current_index) ? "DONE" :
                               (i == status.current_index) ? "CURRENT" : "PENDING";
            std::cout << "[" << i << "] (" << wp.x << ", " << wp.y
                      << ") " << state << std::endl;
        }
    }

----

GUI Demo (simple_gui)
---------------------

OpenCV 기반의 시각화 데모 프로그램입니다. 맵과 로봇 위치를 시각화하고, 마우스로 Waypoint를 설정할 수 있습니다.

실행 방법
^^^^^^^^^

.. code-block:: bash

    ./simple_gui <robot_id> [pcd_path]

    # 예시
    ./simple_gui railab_raibo-3614732983840
    ./simple_gui railab_raibo-3614732983840 ../maps/office1_example.pcd

워크플로우
^^^^^^^^^^

1. ``O`` 키로 PCD 맵 파일 열기
2. 맵에서 클릭하여 로봇 초기 위치 설정
3. 로봇이 바라보는 방향으로 클릭하여 방향(Yaw) 설정
4. ``S`` 키로 맵 전송 및 Localization 시작
5. 맵에서 클릭하여 Waypoint 추가
6. ``W`` 키로 Waypoint 전송 및 자율주행 시작

키보드 단축키
^^^^^^^^^^^^^

.. list-table::
   :header-rows: 1
   :widths: 15 85

   * - 키
     - 기능
   * - ``O``
     - PCD 맵 파일 열기
   * - ``S``
     - 맵 전송 (Localization 시작)
   * - ``W``
     - Waypoint 전송 (자율주행 시작)
   * - ``C``
     - Waypoint 초기화
   * - ``R``
     - 반복 횟수 변경 (1 → 5 → ∞)
   * - ``X``
     - Initial pose 리셋
   * - ``+/-``
     - 줌 인/아웃
   * - ``Q``
     - 종료

마우스 조작
^^^^^^^^^^^

- **좌클릭**: 워크플로우 단계별 동작 (위치/방향/Waypoint)
- **우클릭 드래그**: 화면 이동 (Pan)
- **스크롤**: 줌

상태 표시
^^^^^^^^^

- 화면 하단에 현재 단계 및 다음 동작 안내 표시
- Localization 활성화 전에는 Waypoint 추가 불가
- 이미 Localization이 활성화된 상태에서 ``S`` 를 누르면 리셋 안내

.. note::
    simple_gui는 ``zenity`` 패키지를 사용하여 파일 선택 다이얼로그를 표시합니다.
    Ubuntu에서 ``sudo apt-get install zenity`` 로 설치할 수 있습니다.

----

CMake Configuration
-------------------

.. code-block:: cmake

    cmake_minimum_required(VERSION 3.16)
    project(my_controller)

    set(CMAKE_CXX_STANDARD 17)

    # SDK 경로
    set(RAISIN_SDK_PATH "/path/to/raisin_sdk_install")

    # 의존성
    find_package(Eigen3 REQUIRED)
    find_package(OpenSSL REQUIRED)

    set(PCL_INCLUDE_DIRS "/usr/include/pcl-1.12")
    set(PCL_LIBRARIES pcl_common pcl_io)

    # 실행 파일
    add_executable(my_controller main.cpp)

    target_include_directories(my_controller PRIVATE
        ${CMAKE_SOURCE_DIR}/include
        ${RAISIN_SDK_PATH}/include
        ${PCL_INCLUDE_DIRS}
    )

    target_link_libraries(my_controller PRIVATE
        ${RAISIN_SDK_PATH}/lib/libraisin_network.so
        ${RAISIN_SDK_PATH}/lib/libraisin_thread_pool.so
        ${RAISIN_SDK_PATH}/lib/libraisin_parameter.so
        ${RAISIN_SDK_PATH}/lib/libraisin_encryption.so
        ${RAISIN_SDK_PATH}/lib/libraisin_data_logger.so
        ${RAISIN_SDK_PATH}/lib/libraisin_util.so
        ${RAISIN_SDK_PATH}/lib/libraisim.so
        ${RAISIN_SDK_PATH}/lib/libzstd.so
        Eigen3::Eigen
        OpenSSL::SSL OpenSSL::Crypto
        ${PCL_LIBRARIES}
        pthread dl rt
    )

    set_target_properties(my_controller PROPERTIES
        BUILD_RPATH "${RAISIN_SDK_PATH}/lib"
    )

----

Troubleshooting
---------------

연결 실패
^^^^^^^^^

**증상**: ``connect()`` 반환값이 false

**확인 사항**:

1. ``raisin_master``가 로봇에서 실행 중인지 확인
2. 동일 네트워크에 있는지 확인
3. Robot ID가 정확한지 확인 (raisin_master 콘솔 출력 참조)

맵 로드 실패
^^^^^^^^^^^^

**증상**: ``setMap()`` 실패 또는 타임아웃

**확인 사항**:

1. **Fast-LIO 플러그인**이 로드되어 있는지 확인 (미로드 시: raisin_plugin 문서의 FastLIO 섹션 참조)
2. PCD 파일 경로가 올바른지 확인
3. PCD 파일이 손상되지 않았는지 확인 (``loadPCD()``로 테스트)

로봇이 움직이지 않음
^^^^^^^^^^^^^^^^^^^^

**증상**: ``setWaypoints()`` 성공했지만 로봇이 정지

**확인 사항**:

1. **Autonomy 플러그인**이 로드되어 있는지 확인 (미로드 시: raisin_plugin 문서의 Autonomy 섹션 참조)
2. **frame 이름이 map_name과 일치하는지 확인** (가장 흔한 원인!)
3. Waypoint 좌표가 맵 범위 내에 있는지 확인
4. 조이스틱 오버라이드 상태가 아닌지 확인

.. code-block:: cpp

    // 흔한 실수
    client.setMap("...", 0, 0, 0, 0, "office_map");
    client.setWaypoints({Waypoint("map", 5.0, 0.0)}, 1);  // ✗ "map" != "office_map"

    // 올바른 사용
    client.setMap("...", 0, 0, 0, 0, "office_map");
    client.setWaypoints({Waypoint("office_map", 5.0, 0.0)}, 1);  // ✓

서비스 응답 메시지 목록
^^^^^^^^^^^^^^^^^^^^^^^

**SetWaypoints:**

- ``"set waypoint success"`` - 성공
- ``"waypoint list is empty"`` - 빈 목록

**SetMap (SetLaserMap):**

- ``"Map saved."`` - 성공
- 타임아웃 - Fast-LIO 플러그인 미로드

**GetWaypoints:**

- ``"get waypoint success"`` - 성공

----

FAQ (자주 묻는 질문)
--------------------

이 섹션은 실제 사용자 문의를 바탕으로 작성되었습니다.

.. _faq-valid-field:

Q: MissionStatus와 RobotState의 valid 필드는 무엇인가요?
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

**관련 문서**: :ref:`Data Types <data-types>` 섹션의 ``MissionStatus``, ``RobotState`` 참조

**문의 내용**:

    MissionStatus/RobotState 구조체의 ``valid`` 항목이 어떤 유효성을 검토하는지,
    그리고 어떤 경우에 유효하지 않은 값(false)이 전달되는지 알고 싶습니다.

**답변**:

``valid`` 필드는 **비동기 데이터 수신/서비스 호출의 성공 여부**를 나타냅니다.

**RobotState.valid**

- ``true``: Odometry 데이터를 정상적으로 수신한 상태
- ``false``: 아직 Odometry 데이터를 받지 못함

.. code-block:: cpp

    // 연결 직후에는 valid가 false일 수 있음
    client.connect("ROBOT_ID");
    client.subscribeOdometry([](const RobotState& s) { /* ... */ });

    // 잠시 후 조회
    auto state = client.getRobotState();
    if (!state.valid) {
        // 아직 첫 번째 odometry 메시지를 받지 못함
        std::cout << "Waiting for odometry..." << std::endl;
    }

**MissionStatus.valid**

- ``true``: ``getMissionStatus()`` 서비스 호출이 성공
- ``false``: 서비스 호출 실패 (타임아웃 등)

.. code-block:: cpp

    auto status = client.getMissionStatus();
    if (!status.valid) {
        // 서비스 응답을 받지 못함 (타임아웃 또는 연결 끊김)
        std::cerr << "Failed to get mission status" << std::endl;
    }

**valid가 false인 주요 원인**:

.. list-table::
   :header-rows: 1
   :widths: 30 70

   * - 상황
     - 설명
   * - 로봇 연결 전
     - ``connect()`` 호출 전에 데이터 조회
   * - 연결 직후
     - Subscriber가 아직 첫 메시지를 받지 못함 (1-2초 대기 필요)
   * - 서비스 타임아웃
     - 5초 내에 응답을 받지 못함
   * - 네트워크 끊김
     - 로봇과의 연결이 끊어진 상태
   * - 플러그인 미로드
     - 해당 서비스를 제공하는 플러그인이 로드되지 않음

**권장 패턴**:

.. code-block:: cpp

    // 데이터 조회 전 항상 valid 확인
    auto state = client.getRobotState();
    if (state.valid) {
        std::cout << "Position: " << state.x << ", " << state.y << std::endl;
    } else {
        std::cout << "Data not available yet" << std::endl;
    }

    // 또는 콜백 방식 사용 (콜백이 호출되면 항상 valid)
    client.subscribeOdometry([](const RobotState& state) {
        // 여기서 state.valid는 항상 true
        std::cout << "Position: " << state.x << ", " << state.y << std::endl;
    });

----

관련 문서
---------

- **raisin_master 문서**: 로봇 설정 및 플러그인 로드 방법
- **raisin_plugin 문서**: Autonomy, Fast-LIO 플러그인 상세

----

Indices and tables
==================

* :ref:`genindex`
* :ref:`search`
